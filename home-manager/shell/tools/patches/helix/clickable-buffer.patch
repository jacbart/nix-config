diff --git a/helix-term/src/ui/editor.rs b/helix-term/src/ui/editor.rs
index 9343d55d..6cdccd0a 100644
--- a/helix-term/src/ui/editor.rs
+++ b/helix-term/src/ui/editor.rs
@@ -29,7 +29,7 @@
     graphics::{Color, CursorKind, Modifier, Rect, Style},
     input::{KeyEvent, MouseButton, MouseEvent, MouseEventKind},
     keyboard::{KeyCode, KeyModifiers},
-    Document, Editor, Theme, View,
+    Document, DocumentId, Editor, Theme, View,
 };
 use std::{mem::take, num::NonZeroUsize, ops, path::PathBuf, rc::Rc};
 
@@ -42,6 +42,7 @@ pub struct EditorView {
     pub(crate) last_insert: (commands::MappableCommand, Vec<InsertEvent>),
     pub(crate) completion: Option<Completion>,
     spinners: ProgressSpinners,
+    bufferline_info: BufferLineInfo,
     /// Tracks if the terminal window is focused by reaction to terminal focus events
     terminal_focused: bool,
 }
@@ -66,6 +67,7 @@ pub fn new(keymaps: Keymaps) -> Self {
             last_insert: (commands::MappableCommand::normal_mode, Vec::new()),
             completion: None,
             spinners: ProgressSpinners::default(),
+            bufferline_info: BufferLineInfo::default(),
             terminal_focused: true,
         }
     }
@@ -559,7 +561,7 @@ pub fn tabstop_highlights(doc: &Document, theme: &Theme) -> Option<OverlayHighli
     }
 
     /// Render bufferline at the top
-    pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface) {
+    pub fn render_bufferline(&mut self, editor: &Editor, viewport: Rect, surface: &mut Surface) {
         let scratch = PathBuf::from(SCRATCH_BUFFER_NAME); // default filename to use for scratch buffer
         surface.clear_with(
             viewport,
@@ -582,6 +584,8 @@ pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface)
         let mut x = viewport.x;
         let current_doc = view!(editor).doc;
 
+        self.bufferline_info.clear();
+
         for doc in editor.documents() {
             let fname = doc
                 .path()
@@ -601,9 +605,14 @@ pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface)
             let used_width = viewport.x.saturating_sub(x);
             let rem_width = surface.area.width.saturating_sub(used_width);
 
+            let start_x = x;
             x = surface
                 .set_stringn(x, viewport.y, text, rem_width as usize, style)
                 .0;
+            let end_x = x.min(surface.area.right());
+
+            self.bufferline_info
+                .add_buffer_info(doc.id(), start_x..end_x);
 
             if x >= surface.area.right() {
                 break;
@@ -1125,6 +1134,13 @@ fn handle_mouse_event(
             MouseEventKind::Down(MouseButton::Left) => {
                 let editor = &mut cxt.editor;
 
+                if is_bufferline_visible(editor) && row == 0 {
+                    if let Some(buffer_info) = self.bufferline_info.get_clicked_buffer(column) {
+                        editor.switch(buffer_info.document_id, helix_view::editor::Action::Replace);
+                    }
+                    return EventResult::Consumed(None);
+                }
+
                 if let Some((pos, view_id)) = pos_and_view(editor, row, column, true) {
                     let prev_view_id = view!(editor).id;
                     let doc = doc_mut!(editor, &view!(editor, view_id).doc);
@@ -1177,6 +1193,37 @@ fn handle_mouse_event(
                 EventResult::Ignored(None)
             }
 
+            MouseEventKind::Down(MouseButton::Middle) => {
+                let editor = &mut cxt.editor;
+
+                if is_bufferline_visible(editor) && row == 0 {
+                    if let Some(buffer_info) = self.bufferline_info.get_clicked_buffer(column) {
+                        let view_id = editor.tree.focus;
+                        let view = editor.tree.get(view_id);
+                        let current_document_id = view.doc;
+
+                        if editor.documents.len() <= 1 {
+                            return EventResult::Consumed(None);
+                        }
+
+                        if current_document_id == buffer_info.document_id {
+                            let new_doc_id = editor
+                                .documents
+                                .keys()
+                                .find(|&id| *id != current_document_id)
+                                .copied()
+                                .unwrap();
+
+                            let view = editor.tree.get_mut(view_id);
+                            view.doc = new_doc_id;
+                        }
+                        let _ = editor.close_document(buffer_info.document_id, false);
+                    }
+                    return EventResult::Consumed(None);
+                }
+                EventResult::Ignored(None)
+            }
+
             MouseEventKind::Drag(MouseButton::Left) => {
                 let (view, doc) = current!(cxt.editor);
 
@@ -1511,12 +1558,16 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         cx.editor.resize(editor_area);
 
         if use_bufferline {
-            Self::render_bufferline(cx.editor, area.with_height(1), surface);
+            self.render_bufferline(cx.editor, area.with_height(1), surface);
         }
 
         for (view, is_focused) in cx.editor.tree.views() {
-            let doc = cx.editor.document(view.doc).unwrap();
-            self.render_view(cx.editor, doc, view, area, surface, is_focused);
+            match cx.editor.document(view.doc) {
+                None => (),
+                Some(doc) => {
+                    self.render_view(cx.editor, doc, view, area, surface, is_focused);
+                }
+            };
         }
 
         if config.auto_info {
@@ -1606,6 +1657,48 @@ fn cursor(&self, _area: Rect, editor: &Editor) -> (Option<Position>, CursorKind)
     }
 }
 
+#[derive(Debug, Default)]
+struct BufferLineInfo {
+    visible_buffers: Vec<BufferInfo>,
+}
+
+impl BufferLineInfo {
+    fn clear(&mut self) {
+        self.visible_buffers.clear();
+    }
+
+    fn add_buffer_info(&mut self, document_id: DocumentId, columns: std::ops::Range<u16>) {
+        self.visible_buffers.push(BufferInfo {
+            document_id,
+            columns,
+        });
+    }
+
+    fn get_clicked_buffer(&self, column: u16) -> Option<&BufferInfo> {
+        self.visible_buffers
+            .iter()
+            .find(|cell| cell.columns.contains(&column))
+    }
+}
+
+#[derive(Debug)]
+struct BufferInfo {
+    document_id: DocumentId,
+    // The bufferline column span used to show the document name
+    columns: std::ops::Range<u16>,
+}
+
+fn is_bufferline_visible(editor: &Editor) -> bool {
+    use helix_view::editor::BufferLine;
+    let config = editor.config();
+
+    match config.bufferline {
+        BufferLine::Always => true,
+        BufferLine::Multiple => editor.documents.len() > 1,
+        BufferLine::Never => false,
+    }
+}
+
 fn canonicalize_key(key: &mut KeyEvent) {
     if let KeyEvent {
         code: KeyCode::Char(_),
