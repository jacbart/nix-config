diff --git a/helix-term/src/commands/typed.rs b/helix-term/src/commands/typed.rs
index 82cad838..20ae7b66 100644
--- a/helix-term/src/commands/typed.rs
+++ b/helix-term/src/commands/typed.rs
@@ -204,7 +204,7 @@ fn buffer_gather_paths_impl(editor: &mut Editor, args: Args) -> Vec<DocumentId>
     document_ids
 }
 
-fn buffer_close(
+pub fn buffer_close(
     cx: &mut compositor::Context,
     args: Args,
     event: PromptEvent,
diff --git a/helix-term/src/ui/editor.rs b/helix-term/src/ui/editor.rs
index 9343d55d..794bc8df 100644
--- a/helix-term/src/ui/editor.rs
+++ b/helix-term/src/ui/editor.rs
@@ -1,5 +1,5 @@
 use crate::{
-    commands::{self, OnKeyCallback, OnKeyCallbackKind},
+    commands::{self, buffer_close, OnKeyCallback, OnKeyCallbackKind},
     compositor::{Component, Context, Event, EventResult},
     events::{OnModeSwitch, PostCommand},
     handlers::completion::CompletionItem,
@@ -14,6 +14,7 @@
 };
 
 use helix_core::{
+    command_line::Args,
     diagnostic::NumberOrString,
     graphemes::{next_grapheme_boundary, prev_grapheme_boundary},
     movement::Direction,
@@ -29,7 +30,7 @@
     graphics::{Color, CursorKind, Modifier, Rect, Style},
     input::{KeyEvent, MouseButton, MouseEvent, MouseEventKind},
     keyboard::{KeyCode, KeyModifiers},
-    Document, Editor, Theme, View,
+    Document, DocumentId, Editor, Theme, View,
 };
 use std::{mem::take, num::NonZeroUsize, ops, path::PathBuf, rc::Rc};
 
@@ -42,6 +43,7 @@ pub struct EditorView {
     pub(crate) last_insert: (commands::MappableCommand, Vec<InsertEvent>),
     pub(crate) completion: Option<Completion>,
     spinners: ProgressSpinners,
+    bufferline_info: BufferLineInfo,
     /// Tracks if the terminal window is focused by reaction to terminal focus events
     terminal_focused: bool,
 }
@@ -66,6 +68,7 @@ pub fn new(keymaps: Keymaps) -> Self {
             last_insert: (commands::MappableCommand::normal_mode, Vec::new()),
             completion: None,
             spinners: ProgressSpinners::default(),
+            bufferline_info: BufferLineInfo::default(),
             terminal_focused: true,
         }
     }
@@ -559,7 +562,7 @@ pub fn tabstop_highlights(doc: &Document, theme: &Theme) -> Option<OverlayHighli
     }
 
     /// Render bufferline at the top
-    pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface) {
+    pub fn render_bufferline(&mut self, editor: &Editor, viewport: Rect, surface: &mut Surface) {
         let scratch = PathBuf::from(SCRATCH_BUFFER_NAME); // default filename to use for scratch buffer
         surface.clear_with(
             viewport,
@@ -582,6 +585,8 @@ pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface)
         let mut x = viewport.x;
         let current_doc = view!(editor).doc;
 
+        self.bufferline_info.clear();
+
         for doc in editor.documents() {
             let fname = doc
                 .path()
@@ -601,9 +606,14 @@ pub fn render_bufferline(editor: &Editor, viewport: Rect, surface: &mut Surface)
             let used_width = viewport.x.saturating_sub(x);
             let rem_width = surface.area.width.saturating_sub(used_width);
 
+            let start_x = x;
             x = surface
                 .set_stringn(x, viewport.y, text, rem_width as usize, style)
                 .0;
+            let end_x = x.min(surface.area.right());
+
+            self.bufferline_info
+                .add_buffer_info(doc.id(), start_x..end_x);
 
             if x >= surface.area.right() {
                 break;
@@ -1125,6 +1135,14 @@ fn handle_mouse_event(
             MouseEventKind::Down(MouseButton::Left) => {
                 let editor = &mut cxt.editor;
 
+                if is_bufferline_visible(editor) && row == 0 {
+                    if let Some(buffer_info) = self.bufferline_info.get_clicked_buffer(column) {
+                        editor.switch(buffer_info.document_id, helix_view::editor::Action::Replace);
+                    }
+
+                    return EventResult::Consumed(None);
+                }
+
                 if let Some((pos, view_id)) = pos_and_view(editor, row, column, true) {
                     let prev_view_id = view!(editor).id;
                     let doc = doc_mut!(editor, &view!(editor, view_id).doc);
@@ -1177,6 +1195,43 @@ fn handle_mouse_event(
                 EventResult::Ignored(None)
             }
 
+            MouseEventKind::Down(MouseButton::Middle) => {
+                let editor = &mut cxt.editor;
+
+                if is_bufferline_visible(editor) && row == 0 {
+                    if let Some(buffer_info) = self.bufferline_info.get_clicked_buffer(column) {
+                        // Get the current view
+                        let view_id = editor.tree.focus;
+                        let view = editor.tree.get(view_id);
+
+                        // Get the document (buffer) associated with the current view
+                        let current_document_id = view.doc;
+
+                        // Remove the document from the editor's documents
+                        editor.documents.remove(&buffer_info.document_id);
+
+                        if current_document_id == buffer_info.document_id {
+                            // Update the view to show a different document or create a new scratch buffer
+                            // This is a simplified example; the actual implementation is more complex.
+                            if let Some(new_doc_id) = editor.documents.keys().next() {
+                                // Switch to the next available document
+                                let view = editor.tree.get_mut(view_id);
+                                view.doc = *new_doc_id;
+                            } else {
+                                // No documents left, create a new scratch buffer
+                                // let new_doc = editor.new_document(Document::default());
+                                // let view = editor.tree.get_mut(view_id);
+                                // view.doc = new_doc.id();
+                            }
+                        }
+                    }
+
+                    return EventResult::Consumed(None);
+                }
+
+                EventResult::Ignored(None)
+            }
+
             MouseEventKind::Drag(MouseButton::Left) => {
                 let (view, doc) = current!(cxt.editor);
 
@@ -1511,7 +1566,7 @@ fn render(&mut self, area: Rect, surface: &mut Surface, cx: &mut Context) {
         cx.editor.resize(editor_area);
 
         if use_bufferline {
-            Self::render_bufferline(cx.editor, area.with_height(1), surface);
+            self.render_bufferline(cx.editor, area.with_height(1), surface);
         }
 
         for (view, is_focused) in cx.editor.tree.views() {
@@ -1606,6 +1661,48 @@ fn cursor(&self, _area: Rect, editor: &Editor) -> (Option<Position>, CursorKind)
     }
 }
 
+#[derive(Debug, Default)]
+struct BufferLineInfo {
+    visible_buffers: Vec<BufferInfo>,
+}
+
+impl BufferLineInfo {
+    fn clear(&mut self) {
+        self.visible_buffers.clear();
+    }
+
+    fn add_buffer_info(&mut self, document_id: DocumentId, columns: std::ops::Range<u16>) {
+        self.visible_buffers.push(BufferInfo {
+            document_id,
+            columns,
+        });
+    }
+
+    fn get_clicked_buffer(&self, column: u16) -> Option<&BufferInfo> {
+        self.visible_buffers
+            .iter()
+            .find(|cell| cell.columns.contains(&column))
+    }
+}
+
+#[derive(Debug)]
+struct BufferInfo {
+    document_id: DocumentId,
+    // The bufferline column span used to show the document name
+    columns: std::ops::Range<u16>,
+}
+
+fn is_bufferline_visible(editor: &Editor) -> bool {
+    use helix_view::editor::BufferLine;
+    let config = editor.config();
+
+    match config.bufferline {
+        BufferLine::Always => true,
+        BufferLine::Multiple => editor.documents.len() > 1,
+        BufferLine::Never => false,
+    }
+}
+
 fn canonicalize_key(key: &mut KeyEvent) {
     if let KeyEvent {
         code: KeyCode::Char(_),
diff --git a/helix-view/src/editor.rs b/helix-view/src/editor.rs
index 27dc4523..b3cfaac6 100644
--- a/helix-view/src/editor.rs
+++ b/helix-view/src/editor.rs
@@ -1734,7 +1734,7 @@ pub fn switch(&mut self, id: DocumentId, action: Action) {
     }
 
     /// Generate an id for a new document and register it.
-    fn new_document(&mut self, mut doc: Document) -> DocumentId {
+    pub fn new_document(&mut self, mut doc: Document) -> DocumentId {
         let id = self.next_document_id;
         // Safety: adding 1 from 1 is fine, probably impossible to reach usize max
         self.next_document_id =
